<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JVM概况了解]]></title>
      <url>%2F2017%2F05%2F14%2Fjava%2FJVM%2F2017-05-14-1%2F</url>
      <content type="text"><![CDATA[JVM了解学习 Java程序的跨平台特性主要是指字节码文件可以在任何具有Java虚拟机的计算机或者电子设备上运行，Java虚拟机中的Java解释器负责将字节码文件解释成为特定的机器码进行运行。因此在运行时，Java源程序需要通过编译器编译成为.class文件。众所周知java.exe是Java class文件的执行程序，但实际上java.exe程序只是一个执行的外壳，它会装载jvm.dll（windows下，下皆以windows平台为例，Linux下和solaris下其实类似，为：libjvm.so），这个动态连接库才是java虚拟机的实际操作处理所在。 JVM是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。所以，JAVA虚拟机JVM是属于JRE的，而现在我们安装JDK时也附带安装了JRE(当然也可以单独安装JRE)。 JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data areaclassloader 把硬盘上的class 文件加载到JVM中的运行时数据区域, 但是它不负责这个类文件能否执行，而这个是 执行引擎 负责的。 ##类加载器：作用：装载.class文件classloader 有两种装载class的方式 （时机）：隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM显式：通过class.forname()动态加载类加载器 classloader 是具有层次结构的，也就是父子关系。其中，Bootstrap 是所有类加载器的父亲。这个类加载器不是用 java 语言写的，而是用 C/C++ 写的。 ##执行引擎：作用： 执行字节码，或者执行本地方法 ##运行时数据区：主要包括： Java虚拟机栈：java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。 java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。（JVM将Heap分为两块：新生代New Generation和旧生代Old Generation）， PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。 方法区：方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。 运行时常量池：（其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息）参见个人学习整理的JVM运行时数据区域总结 ##垃圾回收机制GC。垃圾回收机制是由垃圾收集器Garbage Collection GC来实现的，GC是后台的守护进程。垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。参考个人GC学习总结 JVM 的 工作原理，层次结构 以及 GC工作原理Java内存管理：深入Java内存区域]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hibernate学习笔记]]></title>
      <url>%2F2017%2F05%2F11%2Fhibernate%2F2017-05-11%2F</url>
      <content type="text"><![CDATA[hibernate学习笔记1.Hibernate里不对对象或集合对象重载toString方法，不然编译错误 。Stackoverflow错误 栈溢出 2.什么是维护关联关系：一对多时候 设置外键的值多对多时候 就是插入或删除中间表的记录 3对象的状态： 临时状态： 与数据库没有对应，跟Session没有关联。 一般是新new出的对象。 持久化状态： 对象在Session的管理之中，最终会有对应的数据库记录。 特点： a，有OID b，对对象的修改会同步到数据库。 游离状态： 数据库中有对应记录，但对象不在Session管理之中。 修改此状态对象时数据库不会有变化。 4.主键id的生成 &lt;id name=&quot;id&quot;&gt; 5.数据库sql的四个级别：读未提交 1 0001读已提交 2 0010可重复度 4 0100串行化（不可并发） 8 10006.一对一：外键约束 + 唯一性约束比较特殊只有有外键方的一方才能维护关联关系所有解除关联是，没外键的一方解除无效。基于外键的一对一基于主键的一对一 person 在having中不能使用列别名，order by 可以用 8.java中为什么要给类使用代理，有什么好处 http://www.iteye.com/problems/15304 9.懒加载： 也叫延迟加载，不是在执行获取操作时马上生成SQL，而是在第一次使用时生成SQL。 分成两种： 类级别的： &lt;class ... lazy=&quot;true/false&quot;&gt; 属性级别的： &lt;set/list/map/bag ... lazy=&quot;...&quot;&gt; &lt;many-to-one ... lazy=&quot;...&quot;&gt; &lt;one-to-one ... lazy=&quot;...&quot;&gt; 在使用懒加载特性时，可能会有LazyInitializationException异常： 原因： 真正的去获取数据时，Session已经没有了。 解决办法： 方式一：让Session在真正加载后再关闭。 方式二：或是在Sessoin关闭前执行Hibernate.initialize(department.getEmployees()); extra策略：（加强懒加载） 注意！！！与 lazy=“true” 类似. 主要区别是增强延迟检索策略能进一步延迟 Customer 对象的 orders 集合代理实例的初始化时机：• 当程序第一次访问 orders 属性的 iterator() 方法时, 会导致 orders 集合代理类实例的初始化• 当程序第一次访问 order 属性的 size(), contains() 和 isEmpty() 方法时, Hibernate 不会初始化 orders 集合类的实例,仅通过特定的 select 语句查询必要的信息, 不会检索所有的 Order 对象 10.缓存是按id来查询的！ （使用id获得对象 才有效）一级缓存 相对于类对象，二级缓存 相对于sessionfactory，应用级别的缓存。在session查询数据库前的缓存 注意！！！ 对于集合里的二级缓存，不仅要声明此时对象里的集合属性要二级缓存，而且集合里的对应类型对象也要声明是二级缓存。这样才能实现二级缓存的效果！不然的话虽然第一次查询这个集合里的所有数据，第二次查询是集合里的对象所对应的属性还是要再按照其自身的id依次查询（生成对个sql语句），不好。 缓存一般使用在load和get方法query.list()查询方法默认不使用缓存。就算hql语句后又where id=。。。都不行。1.如果要使用query.list()那么要使用迭代器 iterator()；不过有n+1次查询问题，不常用！！！2.也可以使用 .setCacheable(true)// 是否使用查询缓存，需要在hibernate.cfg.xml中开启查询缓存才行(不过hql条件要一致) 1. select new list(p.name, p.address) from Person as p ; select将选择出来的属性存入一个List对象中 select new ClassTest(p.name, p.address) from Person as p;select将选择出来的属性封装成对象,前提是ClassTest支持p.name, p.address的构造函数, select new map(p.name as personName) from Person as p ;select将选中的表达式命名为别名,这种用法与new map()结合,选择出来的是Map结构,以personName为key,将实际选择出来的值作为value]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的基本数据类型和引用类型]]></title>
      <url>%2F2017%2F05%2F10%2Fjava%2Fjava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F2017-05-10%2F</url>
      <content type="text"><![CDATA[java的基本数据类型和引用类型 基本类型：简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。 引用数据类型：Java语言本身不支持C++中的结构（struct）或联合（union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏 一、8种基本基本数据类型（分布尔类型和数值类型）。1、4种整型 byte 1字节 -128——127 short 2 字节 -32,768 —— 32,767 int 4 字节 -2,147,483,648 —— 2,147,483,647（超过20亿） long 8 字节 -9,223,372,036,854,775,808——9,223,372,036854,775,807 注释：java中所有的数据类所占据的字节数量与平台无关，java也没有任何无符号类型2、 2种浮点类型 float 4 字节 32位IEEE 754单精度（有效位数 6 – 7位） double 8 字节 64位IEEE 754双精度（有效位数15位）3、1种Unicode编码的字符单元 char 2 字节 整个Unicode字符集4、1种真值类型 boolean 1 位 true或者false ##二、种引用类型类class接口interface数组array ##三、Java数据类型在内存中的存储： 给变量赋值前需要先确定变量的类型，确定了变量的类型，即确定了数据需分配内存空间的大小，数据在内存的存储方式。1）基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，而Java语言里面八种数据类型是这种存储模型； 2）引用类型的存储原理:引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的（存储对象地址），而对象本身（实例化后的对象）的值存储在内存堆上的； 区别:基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的()（需要java中的栈、堆概念） 四、“==”和equal()对数据类型的分析:12345678910111213eg1:定义两个String对象（String不是基本数据类型）//String是一个特殊的包装类数据。可以用以下两种方式创建：//String str = new String(“abc”)；String str = “abc”;String a=&quot;abc&quot;;//栈中的a引用变量指向JVM运行时数据区区域方法区的常量池中的“abc”。String b=&quot;abc&quot;;//栈中的b引用变量也指向方法区中的常量池中的&quot;abc&quot;，和a指向的地址一样String c = new String(&quot;abc&quot;); //new一个新的String实例对象，引用变量c指向实例化对象new String(&quot;abc&quot;)的地址，该实例化对象存储在堆中[ **实际该地址指针（地址存在堆中）指向此对象类型数据（存在方法区中数据值）即abc**]，这和存在常量池的“abc”值得地址不一样。if(a==b)&#123;System.out.println(&quot;a==b&quot;);&#125;else&#123;System.out.println(&quot;a!=b&quot;);&#125;System.out.printLn(a==c) 结果：程序输出a==b flase原因:a和b引用变量指向的地址的是相同的，a==b比较的是两个引用变量所指向的地址。 a和c引用变量指向的地址的是不相同的，a指向常量区中的abc，c指向新开辟在堆内存中的String对象实例中的abc实例对象中数据值得地址；两个地址不同，==比较返回false。 images 参考eg2：定义两个基本数据类型 12345678int a=4; //栈中的a引用变量指向方法区中的常量池中的4int b=4; //栈中的b引用变量也指向方法区中的常量池中的4if(a==b)&#123;System.out.println(&quot;a==b&quot;);&#125;else&#123; System.out.println(&quot;a!=b&quot;); &#125; 结果：输出：a==b原因：a和b指向同一个常量区中常量4的地址。==比较两者地址相等。 不管是引用类型或基本数据类型使用“==”比较，实际上他们都先在栈空间创建了一个各自的变量引用如int a=1 或String b 等，并比较他们指向的地址的值； 如果给基本数据类型赋值，实际是先将在方法区中的常量区中查找是否存在值1的地址（该值有一个唯一的地址），如果存在则将a指向该地址；不存在那么在常量区新建一个值为1的空间，并将该值得地址赋值给a。如果重新给a赋值如：a = 2，同理将a指向的地址改为常量区中值为2的地址。注意 int c =1，代表a和b指向同一个地址（常量区中1的地址）。 如果使用new 实例化对象，对象的引用变量指向的是在堆中该对象实例化的对象地址； equal()方法比较的是引用变量指向地址最终指向的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java集合汇总]]></title>
      <url>%2F2017%2F05%2F09%2Fjava%2F%E9%9B%86%E5%90%88%2F2017-05-09%2F</url>
      <content type="text"><![CDATA[java集合汇总几个主要结合的主要关系：Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap 一、集合与数组 数组：是用来存储对象（存储对象的引用，java的基本数据类型和引用类型）和基本数据类型的一种容器，但是数组的长度在创建时候已经固定，不适合在对象数量未知的情况下使用。 集合：通俗的讲集合是一个存放数据的容器，准确的讲集合是一个 存放数据对象引用的容器，并非对象本身。（只能存储对象，对象类型可以不一样），集合长度可变，可在多数情况下使用。注意：集合存放的都是对象的引用，那些看似存放着基本数据类型其实已经通过java自动装，拆箱操作装成了相应的对象。123List list =new ArrayList();list.add(12);System.out.println(list.get(0).getClass().getName());//Integer类型 自动装、拆箱 二、层次关系 如图所示：图中，实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口： ##集合框架图： Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素（set集合的去重原理）。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。 Iterator（迭代接口），所有的集合类，都实现了Iterator接口，所以不论Collection实际类型是哪一个都支持iterator()的方法，该方法返回一个迭代子。这是一个用于遍历集合中元素的接口，主要包含以下三种方法：1.hasNext()是否还有下一个元素。2.next()返回下一个元素。3.remove()删除当前元素。典型使用：1234Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) &#123; Object obj = it.next(); // 得到下一个元素 &#125; 注意：Collection collection = new ArrayList();（这样写的好处在于，以后如果要引用不同的集合，可以省略很多麻烦。因为都是用Collection接口里的方法，java多态的提现，向上转型）容器类对象在调用remove,contains等方法时需要比较对象是否相等地，这会涉及到对象类型的equals方法和hashcode方法。即，相等的对象应该有相等的hashcode.当然，如果是自定义的类型，需要重写这两个方法 三、几种重要的集合接口和类简介 1、List（有序、可重复）List 接口继承了 Collection 接口以定义一个允许重复项的有序集合。该接口不但能够对列表的一部分进行处理，还添加了面向位置的操作。有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器注意：尽管列表允许把自身作为元素包含在内，但建议要特别小心：在这样的列表上，equals 和 hashCode 方法不再是定义良好的。 2、Set（无序、不能重复）Set接口同样是Collection接口的一个子接口，它表示数学意义上的集合概念。Set中不包含重复的元素，即Set中不存两个这样的元素e1和e2，使得e1.equals(e2)为true。由于Set接口提供的数据结构是数学意义上集合概念的抽象，因此它需要支持对象的添加、删除，而不需提供随机访问。故Set接口与Collection的接口相同。Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，set可以存入null和boolean型。 3、Map（键值对、键唯一、值不唯一）Map 接口不是 Collection 接口的继承。而是从自己的用于维护键-值关联的接口层次结构入手。按定义，该接口描述了从不重复的键到值的映射。Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 四、遍历 在类集中提供了以下四种的常见输出方式：1）Iterator：迭代输出，是使用最多的输出方式。2）ListIterator：是Iterator的子接口，专门用于输出List中的内容。3）foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。4）for循环代码示例如下：12345for的形式：for（int i=0;i&lt;arr.size();i++）&#123;...&#125;foreach的形式： for（int i：arr）&#123;...&#125;iterator的形式：Iterator it = arr.iterator();while(it.hasNext())&#123; object o =it.next(); ...&#125; 集中常用的对应实现类总结五、（实现List集合接口）ArrayList、LinkedList，和VectorArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。即：ArrayList ：读快改慢，动态数组 LinkedList：改快读慢，链表，队列，堆栈。 Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。 六、Set集合（HashSet和TreeSet）HashSet：使用哈希表实现的，HashSet集合是无序的，可以存入null当只能存一个，存入的对象或数据唯一。TresSet：使用二叉树实现，集合是有序且自动排列好的（默认升序排序）。可以通过实现Comparable接口，重写接口里面的compareTo(Object obj)方法来自定义排序，该方法返回一个整数值。该集合不允许放入null值。参考：TreeSet和HashSet的区别注意：HashSet 和 TreeSet 都实现 Cloneable 接口。HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的 String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例 。 七、Map集合 实现类：HashMap、Hashtable、LinkedHashMap和TreeMap HashMapHashMap是最常用的Map（无序的），它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的，效率高。 HashtableHashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 ConcurrentHashMap线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 LinkedHashMapLinkedHashMap保存了记录的插入顺序（有序的），在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 TreeMapTreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的；所以在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按顺序遍历键，那么TreeMap 会更好。自定义排序例子：123456789TreeMap&lt;Double,Object&gt; rf = new TreeMap&lt;Double,Object&gt;(new Comparator()&#123; @Override public int compare(Object o1, Object o2) &#123; // TODO Auto-generated method stub 重写compare方法，降序排列 Double a = (Double)o1; Double b = (Double)o2; return -a.compareTo(b); &#125;&#125;); map的遍历 第一种：KeySet()将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。典型用法如下：Map map = new HashMap();map.put(“key1”,”lisi1”);map.put(“key2”,”lisi2”);map.put(“key3”,”lisi3”);map.put(“key4”,”lisi4”);//先获取map集合的所有键的set集合，keyset（）Iterator it = map.keySet().iterator(); //获取迭代器while(it.hasNext()){Object key = it.next();System.out.println(map.get(key));} 第二种：entrySet（）Set]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java编译原理了解]]></title>
      <url>%2F2017%2F05%2F08%2Fjava%2Fjava%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F2017-05-08-1%2F</url>
      <content type="text"><![CDATA[java编译原理java源代码(符合语言规范)–&gt;javac–&gt;.class(二进制文件)–&gt;jvm–&gt;机器语言(不同平台不同种类) 语义分析器、语法分析器、语义分析器、代码生成器源码-&gt;token流-&gt;语法树-&gt;注解语法树-&gt;字节码images 流程： 词法分析器：将源码转换为Token流将源代码划分成一个个Token(找出java语言中的if，else，for等关键字) 语法分析器：将Token流转化为语法树将上述的一个个Token组成一句句话（或者说成一句句代码块），检查这一句句话是不是符合Java语言规范(如if后面跟的是不是布尔判断表达式) 语义分析器：将语法树转化为注解语法树将复杂的语法转化成简单的语法（eg.注解、foreach转化为for循环、去掉永不会用到的代码块）并做一些检查，添加一些代码(默认构造器) 代码生成器：将注解语法树转化为字节码(即将一个数据结构转化成另一个数据结构) ps：要获取javac编译器，可以通过OpenJDK来下载源码，可以自己编译javac的源码，也可以通过调用jdk的 学习参考Javac编译原理 Java编译原理（有感）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java对象转型]]></title>
      <url>%2F2017%2F05%2F08%2Fjava%2F2017-05-08%2F</url>
      <content type="text"><![CDATA[java对象转型 向上转型和向下转型 什么是对象转型?对象转型是在继承的基础上而言的，对象类型转换主要包含向上转型和向下转型。继承是java面向对象的基本特征之一，是代码复用的一种机制，通过继承子类可以复用父类的方法等；如果父类的方法不满足子类的需求，子类可以通过重写父类的方法或者新增属于自己特性的方法对自身的功能加以扩展。 1向上转型：子类引用的对象转换为父类类型称为向上转型。子类的对象转为父类对象，此处父类对象可以是接口。{eg：Annimal dog =new Dog();} 2向下转型：父类引用的对象转换为子类类型称为向下转型。{eg：Dog dog =new Animal();//不安全的向下转型上述编译通过，但是运行时候报错，类型转换错误！正确操作：Annimal ad =new Dog()；Dog dog = （Dog）ad；} 向上转型注意： 前者是一个向上转型，Animal dog 引用指向new Dog();子类对象当成父类对象，只能调用父类的成员，如果子类重写了父类的方法就根据这个引用指向调用子类重写的这个方法（这个方法就是覆盖override）。这个调用过程就称为“动态绑定”。（即子类重写父类方法，向上转型对象调用该方法，方法指向子类中重写的方法） 向上转型时，父类指向子类引用对象会遗失除与父类对象共有的其他方法，也就是在转型过程中，子类的新有的方法都会遗失掉，在编译时，系统会提供找不到方法的错误。如： 12345678910111213141516171819 public class Animal &#123; public void eat()&#123; System.out.println(&quot;animal eatting...&quot;); &#125;&#125;class Bird extends Animal&#123; public void eat()&#123; System.out.println(&quot;bird eatting...&quot;); &#125; public void fly()&#123; System.out.println(&quot;bird flying...&quot;); &#125;&#125;class Main&#123; public static void main(String[] args) &#123; Animal b=new Bird(); //向上转型 b.eat(); b.fly(); //此处提示在Animal中没有定义fly方法。｝ 向下转型注意：情况一：如果父类引用的对象如果引用的是指向的子类对象（即先向上转型），那么在向下转型的过程中是安全的。也就是编译是不会出错误的。此时对象可以调用子类所有的成员。情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。 12345678910111213 class Main&#123; public static void main(String[] args) &#123; Animal b=new Bird(); //先向上转型（父类引用对象指向子类对象） Bird bird = (Bird) b;//向下转型，编译和运行都不报错 Animal a=new Animal(); //（父类引用对象指向父类本身对象） Bird bird = (Bird) a;//不安全的向下转型，编译正常，运行报错（类型转换错误） //解决方法 instance of if(a instanceof Bird)&#123; Bird bird=(Bird) a; bird.eat(); bird.fly(); &#125;｝ 总结：1、父类引用可以指向子类对象，子类引用不能指向父类对象。2、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。3、把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型。4、upcasting 会丢失子类特有的方法,但是子类overriding 父类的方法，子类方法有效 。5、向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了JAVA的抽象编程思想。 参考:夜雨阑珊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Let Your Heart Hold Fast]]></title>
      <url>%2F2017%2F04%2F16%2Fmusic%2F2017-04-16%2F</url>
      <content type="text"><![CDATA[Let Your Heart Hold FastAll my days are spent 那飞速逝去的时日All my cards are dealt那已经确定的命运Oh ,the descolation grows悲凉无尽蔓延心脏Every inch revealed心脏每一寸As my heart is pierced都被刺穿Oh,my soul is now exposed灵魂彻底暴露In the ocean deep穿过深邃的海洋In the canyons steep越过险峻的峡谷Walls of granite here I stand我立在岩石之上All my desperate calls我所有绝望的呼唤Rcho off the walls在墙间回荡Back and forth;then back again久久不息To believe I walk alone相信自己能踽踽独行Is a lie that I’ve been told这是别人告诉我的谎言So let your heart hold fast所以不要灰心丧气For this soon shall pass因为一切都将成为过去Like the high tide takes the sand就像沙子会被海潮带走Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,Oh！哦~Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,！哦~Oh,Oh,Oh,Oh,Oh！哦~At the bitter end在痛苦的最后Salt and liquid blend泪水涌出From the corner of eyes从我的眼角滑落All the miles wrecked蹒跚走过的所有路Every broken step艰难走过的每一步Always searching,always blind一直在盲目的寻找Never fear!No!Never fear!不要畏惧！不要畏惧！Never fear!No! Never fear!永不畏惧！永不畏惧！So let your heart hold fast所以不要灰心丧气For this soon shall pass因为一切将成为过去There’s another hill ahead前方将是人生的另一座高峰&gt; 这世上总有很多我们无法掌控的事情，就像我想你一样，总是那么的不经意间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flask get/post参数获取]]></title>
      <url>%2F2017%2F03%2F22%2Fpython%2Fflask%2F2017-03-22%2F</url>
      <content type="text"><![CDATA[flask 使用笔记获得get和post 提交的参数post 提交参数获取request.form[‘xxx’] 其类型为：ImmutableMultiDict123456@app.route(&quot;/deleteInfo&quot;, methods=[&apos;post&apos;])@allow_cross_domaindef delete_info(): print(type(request.form)) # &lt; class &apos;werkzeug.datastructures.ImmutableMultiDict&apos;&gt; _id = request.form[&quot;_id&quot;] get 提交参数获取1234@app.route(&apos;/queryDetl&apos;)@allow_cross_domaindef query_detail(): _id = request.args.get(&quot;_id&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决Flask 跨域请求问题]]></title>
      <url>%2F2017%2F03%2F21%2Fpython%2Fflask%2F2017-03-21%2F</url>
      <content type="text"><![CDATA[python flask 跨域访问装饰器实现现在大多数的web项目都已经是前后端分离；一般纯的api接口需要考虑跨域访问问题 下面是简单的跨域访问装饰器在flask中的实现（其他语言web项目跨域处理方法类似）12345678910111213141516171819from functools import wrapsfrom flask import make_responsedef allow_cross_domain(fun): @wraps(fun) def wrapper_fun(*args, **kwargs): rst = make_response(fun(*args, **kwargs)) rst.headers[&apos;Access-Control-Allow-Origin&apos;] = &apos;*&apos; rst.headers[&apos;Access-Control-Allow-Methods&apos;] = &apos;PUT,GET,POST,DELETE&apos; allow_headers = &quot;Referer,Accept,Origin,User-Agent&quot; rst.headers[&apos;Access-Control-Allow-Headers&apos;] = allow_headers return rst return wrapper_fun@app.route(&apos;/hosts/&apos;)@allow_cross_domaindef domains(): pass]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[my first hexo]]></title>
      <url>%2F2017%2F03%2F20%2Fmy-first-hexo%2F</url>
      <content type="text"><![CDATA[hello glinlf and hexo!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用grequests 异步IO批量请求]]></title>
      <url>%2F2017%2F03%2F18%2Fspider%2F2017-03-18%2F</url>
      <content type="text"><![CDATA[python grequests 库的使用记录 简介： 对于大名鼎鼎的request库相信大家都已经非常熟悉了，不过他有个不好的缺点就是阻塞性IO，在你使用request.get()获取所需要的网页时，除非这个网页下载完成，不然不能进行对新网页的获取；而cup的处理速度远比IO读写的速度快多了，为了充分利用cpu，加快网页爬取速度，这里讲介绍使用异步IO获取网页的grequests库的使用。这两个库都是 kennethreitz开发的，用法非常相似。 安装installpip install grequests 基础用法 12345678910111213141516171819#要爬取的url集合urls = [ url = &apos;https://www.zhihu.com/people/excited-vczh/following&apos;, url = &apos;https://www.zhihu.com/people/liaoxuefeng/following&apos;, url = &apos;https://www.zhihu.com/people/hellolin-30/following&apos;]#同时将上述请求发送rs = (grequests.get(u) for u in urls)#查看发送请求的响应状态码和响应结果： respond_html=[] for resp in grequests.map(rs, exception_handler=exception_handler): # grequests.map可以查看异步io么一个请求返回的状态码200 500 # print(&apos;status:&#123;0&#125; url:&#123;1&#125;&apos;.format(resp, resp.url)) if resp is not None: respond_html.append(resp.text) else: continue 异常的处理 12def exception_handler(request, exception): print(&apos;got exception request: &#123;0&#125;, exception &#123;1&#125;&apos;.format(request, exception)) 异步IO实际运用效果的反思： a.原本毕设在做一个基于python的知乎用户信息特征爬虫系统的，为了加快爬取速度思考使用异步IO，主要思路： 1 对用户信息的的请求入口使用异步IO（grequests）请求多个url地址 2 每一个用户关注人又有多个分页，对分页进行异步IO请求。 原先未使用grequests库，由于阻塞IO的影响，每次只能爬取一个用户信息，再爬取每一用户第一页下的关注人url地址（实际未爬全所有该用户关注的用户）；速度爬取相对较快；使用grequests后去爬取某个用户所有分页下的关注人url后，速度开始变慢，主要原因是：在爬取这个用户后，接着要全部爬完和解析所有分页的html（基本爬全所有关注的用户）；比如某个用户关注上万人，系统爬取该用户下所有关注人都要耗费大把时间。所以异步IO提速还需要看实际的运用情况和环境。比如本身网络带宽限制，机器硬件限制等等都会影响到整体的速度。 b.爬取过程的问题： 虽然该系统只是爬取用户的关注人，不爬取被关注人信息。所以不存在关注和被关注的关系，当是存在 多个人关注同一个人的情况，所以如果爬取所有每个人的关注人，仍然存在爬取了很多重复性爬过的过户，特别是爬取解析分页网页（某个用户关注人特别多的情况）；耗费资源时间却做很多无用功。 个人解决方法：控制爬取的分页数（实际爬去的分页数还需算法和大数据理论支撑），概率性爬取关注人的url（分页下）。存在多人关注同一人的关系便存在概率性爬取到此用户的可能。 缺点：部分概率爬取不到关注用户；爬取的用户数据不全。 grequets使用代理12proxies = &#123;&apos;http&apos;: &apos;http://219.148.108.126:8998&apos;&#125;s = (grequests.get(u, proxies=proxies) for u in urls) 参考 https://pypi.python.org/pypi/grequests https://github.com/kennethreitz/grequests http://blog.upeoe.com/2016/11/24/how-to-use-grequest/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python全局变量]]></title>
      <url>%2F2017%2F03%2F17%2Fpython%2F2017-03-17%2F</url>
      <content type="text"><![CDATA[python全局变量使用: 1 可以直接定义一个globalvar.py文件；里面存放其他文件要使用的变量。在其他文件中导入: 12345678910111213141516171819202122232425262728from src.globalvar import *# __author_=&quot;gLinlf&quot;# coding=utf-8import queue# 定义全局变量# 已经爬取得到所有urlhad_url = set()# 已经爬取解析用户的urlhad_used_url = set()# 用户关注的其他用户的url 使用队列（使用后删除）follow_url = queue.Queue(maxsize=0)# 爬虫入口# follow_url.put(&apos;https://www.zhihu.com/people/liaoxuefeng&apos;)follow_url.put(&apos;https://www.zhihu.com/people/competitionlaw&apos;)# 请求头header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&apos;&#125;# 数据库名db_name = &apos;test&apos;# 抽样爬取不大于10个分页的用户(200人)（加快用户信息爬取速度！概率性减少 花费早爬取页面中存在较多已经爬去的用户url 的资源和时间。）max_page = int(10)# 异步IO请求解析的最大页码数max_parse_page = int(5) 2使用global关键字声明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodbengine 使用记录]]></title>
      <url>%2F2017%2F03%2F16%2Fmongodb%2F2017-03-16%2F</url>
      <content type="text"><![CDATA[mongoengine操作mongodb的使用笔记参见mongoengine文档 1 安装mongoengine pip install -U mongoengine 2 在python3.5中创建连接 mongoengine.connect（db = None，alias =’default’，** kwargs ） 2.1如果使用的时本地连接，则由’db’参数指定的数据库，直接连接数据库例如： mongoengine.connect(‘testdb’) 2.2如果数据库不在localhost的默认端口上运行，也可以在此处提供连接设置(如果需要验证，请提供用户名和密码参数。)： 1mongoengine.register_connection（alias，name = None，host = None，port = None，read_preference = Primary（），username = None，password = None，authentication_source = None，authentication_mechanism = None，** kwargs ） 参数： alias - 将用于在MongoEngine中引用此连接的名称 name - 要使用的特定数据库的名称 host - 要连接的mongod实例的主机名 port - mongod实例正在运行的端口 read_preference - 集合的读取首选项**添加pymongo 2.1 username - 要进行身份验证的用户名 密码 - 要验证的密码 authentication_source - 要进行身份验证的数据库 authentication_mechanism - 数据库认证机制。默认情况下，对MongoDB 3.0及更高版本使用SCRAM-SHA-1，对较旧的服务器使用MONGODB-CR（MongoDB Challenge Response协议）。 is_mock - 明确使用mongomock进行连接（也可以使用mongomock：//作为db主机前缀） kwargs - 要传递到pymongo驱动程序的特定参数，例如maxpoolsize，tz_aware等。有关完整列表，请参阅pymongo的MongoClient文档。 mongoengine在python中的基本使用：新增（save） 创建py文件testmongo.py 类为TestCategories ，TestCategories类似存入mongodb数据库中的表： import mongoengine class TestCategories(mongoengine.Document): # 用户信息地址 user_url = mongoengine.StringField() # 用户名 user_name = mongoengine.StringField() # 用户居住所在地 user_locations = mongoengine.ListField() 在另一个py文件创建一个测试文件 test.py: from src.testmogo import TestCategories from mongoengine import * connect(&apos;test&apos;) cate = TestCategories() cate.user_url = &apos;hello&apos; cate.user_name= &apos;python&apos; cate.user_locations = [&apos;llf&apos;] cate.save() 执行 test.py文件查看 数据库结果： 查询对于objects的到只是一个queryset类（QuerySet），这类里面有丰富的信息，存放所有查询到的 document对象（TestCategories）的list集合。可以使用for in list 语法将查询到的类对象里的数据灵活拼接成一个新的dict或list。 参考：Python中QuerySet和Objects类 obj = TestCategories.objects(user_url=&apos;123&apos;) #&lt;class &apos;mongoengine.queryset.queryset.QuerySet&apos;&gt; print(type(obj)) #&lt;TestCategories:TestCategoriesobject&gt; print(obj) for i in obj: print(i.user_url) 更新安装 django的web框架后 有update（）等方法。 obj = TestCategories.objects(user_url=&apos;123&apos;)获得的就是对应的document。 obj.user_url = &apos;321&apos; obj.update() 常规更新： obj = TestCategories.objects(user_url=&apos;123&apos;) #&lt;class &apos;mongoengine.queryset.queryset.QuerySet&apos;&gt; print(type(obj)) #[&lt;TestCategories: TestCategories object&gt;, &lt;TestCategories: TestCategories object&gt;] print(obj) for obj in objs: print(obj.user_url) # 直接操作 obj（TestCategories）对象 ，修改对应的字段值，更新！ obj.user_name = &apos;xx&apos; obj.save() 删除]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[How to use selenium]]></title>
      <url>%2F2017%2F03%2F13%2Fspider%2F2017-03-13%2F</url>
      <content type="text"><![CDATA[python 异步爬取库selenium使用记录简介 1 在做基于python的知乎用户信息特征爬虫系统中，遇到了个人信息需要点击 查看详细资料后 页面才能渲染出所有我所需要的用户信息。对于基于异步请求的动态网页爬虫，在研究了相关资料后发现这个暴力牛逼的包selenium，相对简单实用。简单来说就是模拟人为对浏览器的动作，比如：点击事件，填写表单等。这样就能克服操作我们传统爬虫只能爬取静态网页，得不到异步请求渲染后的网页信息。具体安装如下：安装selenium（python3.5，window10环境下） 1.通过pip安装 pip install selenium 2.通过下载selenium安装包 selenium连接https://pypi.python.org/pypi/selenium解压，cmd进入目录：E:\selenium\selenium2.53.5&gt; python3 setup.py install 安装浏览器驱动chromedriver（以google为例） 1.下载Chromedriver 下载地址：http://chromedriver.storage.googleapis.com/index.html 注意：先查看notes.txt，Chromedriver版本和浏览器版本一定要对应。否者会出现各种异常报错。 2.解压chromedriver.zip文件将里面的chromedriver.exe文件拷贝到谷歌浏览器的安装目录下： C:\Program Files (x86)\Google\Chrome\Application 3.配置环境变量 打开:我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量 打开path在最后面添加 ;C:\Program Files (x86)\Google\Chrome\Application 测试 打开python编辑器 如pyCharm 编辑代码： chromedriver = “C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe”os.environ[“webdriver.chrome.driver”] = chromedriverdriver = webdriver.Chrome(chromedriver)driver.get(‘http://www.baidu.com‘) 如果跳出google浏览器，且为百度页面则安装成功。不知道为什么其他博客只需要： driver = webdriver.Chrome()driver.get(‘http://www.baidu.com‘) 便能成功。而且我环境变量也已经配置。不知道啥原因，有待研究下。 ———————————————————————————————selenium使用记录模拟知乎登录（具体使用查看文档） 引用链接：https://www.zhihu.com/question/46528604?sort=created ###a先实例化一个driver chrome_driver = “C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe” os.environ[&quot;webdriver.chrome.driver&quot;] = chrome_driver driver = webdriver.Chrome(chrome_driver) ###b 登录知乎，亲自测试可行： driver.get(“http://www.zhihu.com“) #打开知乎我们要登录time.sleep(2) #让操作稍微停一下driver.find_element_by_link_text(‘登录’).click() #找到‘登录’按钮并点击time.sleep(2) # 找到输入账号的框，并自动输入账号 这里要替换为你的登录账号driver.find_element_by_name(‘account’).send_keys(‘你的账号’)time.sleep(2)# 密码，这里要替换为你的密码driver.find_element_by_name(‘password’).send_keys(‘你的密码’)time.sleep(2)# 输入浏览器中显示的验证码，这里如果知乎让你找烦人的倒立汉字，手动登录一下，再停止程序，退出#浏览器，然后重新启动程序，直到让你输入验证码yanzhengma=input(‘验证码:’) #现在好像不需要验证码driver.find_element_by_name(‘captcha’).send_keys(yanzhengma) # 找到登录按钮，并点击driver.find_element_by_css_selector(‘div.button-wrapper.command &gt; button’).click() ###c 使用driver.page_source 可以获得实际操作后的页面源码。而requests库只能获得打开连接的静态网页。如：html = driver.page_source接下来就可以使用BeautifulSoup库来自由操作了。]]></content>
    </entry>

    
  
  
</search>
